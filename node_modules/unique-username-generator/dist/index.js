"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PROFANITY = exports.nouns = exports.adjectives = exports.uniqueUsernameGenerator = exports.generateUsername = exports.generateFromEmail = exports.generateMany = exports.generateUniqueAsync = void 0;
const data_1 = require("./data");
const random_1 = require("./utils/random");
const profanity_1 = require("./data/profanity");
function generateUniqueAsync(config, isTaken, maxAttempts = 1000) {
    return __awaiter(this, void 0, void 0, function* () {
        const used = new Set();
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const candidate = uniqueUsernameGenerator(config);
            if (used.has(candidate))
                continue;
            const taken = yield Promise.resolve(isTaken(candidate));
            if (!taken)
                return candidate;
            used.add(candidate);
        }
        throw new Error("Unable to find a unique username within the given attempts");
    });
}
exports.generateUniqueAsync = generateUniqueAsync;
function generateMany(options) {
    const { count, unique = false } = options, rest = __rest(options, ["count", "unique"]);
    const results = [];
    const seen = new Set();
    for (let i = 0; i < count; i++) {
        let candidate = uniqueUsernameGenerator(rest);
        if (unique) {
            let spins = 0;
            while (seen.has(candidate) && spins < 1000) {
                candidate = uniqueUsernameGenerator(rest);
                spins++;
            }
            if (seen.has(candidate)) {
                throw new Error("Unable to produce the requested number of unique usernames");
            }
            seen.add(candidate);
        }
        results.push(candidate);
    }
    return results;
}
exports.generateMany = generateMany;
const randomNumber = (maxNumber) => {
    let randomNumberString;
    switch (maxNumber) {
        case 1:
            randomNumberString = Math.floor((0, random_1.getRandomInt)(1, 9)).toString();
            break;
        case 2:
            randomNumberString = Math.floor((0, random_1.getRandomInt)(10, 90)).toString();
            break;
        case 3:
            randomNumberString = Math.floor((0, random_1.getRandomInt)(100, 900)).toString();
            break;
        case 4:
            randomNumberString = Math.floor((0, random_1.getRandomInt)(1000, 9000)).toString();
            break;
        case 5:
            randomNumberString = Math.floor((0, random_1.getRandomInt)(10000, 90000)).toString();
            break;
        case 6:
            randomNumberString = Math.floor((0, random_1.getRandomInt)(100000, 900000)).toString();
            break;
        default:
            randomNumberString = "";
            break;
    }
    return randomNumberString;
};
function generateFromEmail(email, second) {
    var _a;
    // Retrieve name from email address
    const nameParts = email.replace(/@.+/, "");
    // Replace all special characters like "@ . _ ";
    let name = nameParts.replace(/[&/\\#,+()$~%._@'":*?<>{}]/g, "");
    const opts = typeof second === "object" && second !== null
        ? second
        : { randomDigits: typeof second === "number" ? second : undefined };
    const stripLeading = opts.stripLeadingDigits !== false; // default true
    const fallback = (_a = opts.leadingFallback) !== null && _a !== void 0 ? _a : "user";
    if (stripLeading) {
        name = name.replace(/^[0-9]+/, "");
        if (name.length === 0) {
            name = fallback;
        }
    }
    // Create and return unique username
    const digits = typeof opts.randomDigits === "number" ? opts.randomDigits : undefined;
    return name + randomNumber(digits);
}
exports.generateFromEmail = generateFromEmail;
function generateUsername(separator, randomDigits, length, prefix) {
    const nouns = safeNouns();
    const adjectives = safeAdjectives();
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    const adjective = prefix ? prefix.replace(/\s{2,}/g, " ").replace(/\s/g, separator !== null && separator !== void 0 ? separator : "").toLocaleLowerCase() : adjectives[Math.floor(Math.random() * adjectives.length)];
    let username;
    // Create unique username
    if (separator) {
        username = adjective + separator + noun + randomNumber(randomDigits);
    }
    else {
        username = adjective + noun + randomNumber(randomDigits);
    }
    if (length) {
        return username.substring(0, length);
    }
    return username;
}
exports.generateUsername = generateUsername;
function uniqueUsernameGenerator(config) {
    var _a, _b, _c, _d;
    if (!config.dictionaries) {
        throw new Error("Cannot find any dictionary. Please provide at least one, or leave " +
            "the 'dictionary' field empty in the config object");
    }
    else {
        // Build filters
        const blocklist = Array.from(new Set([...((_a = config.profanityList) !== null && _a !== void 0 ? _a : profanity_1.DEFAULT_PROFANITY), ...((_b = config.exclude) !== null && _b !== void 0 ? _b : [])]))
            .filter((w) => !!w);
        const isBlocked = (0, profanity_1.buildProfanityFilter)(blocklist, config.profanityOptions);
        // Wrap dictionaries to filter out blocked terms
        const filteredDictionaries = config.dictionaries.map((dict) => dict.filter((w) => !isBlocked(String(w))));
        const usableDictionaries = filteredDictionaries.filter((d) => d.length > 0);
        if (usableDictionaries.length === 0) {
            throw new Error("All provided dictionaries are empty after filtering. Consider relaxing filters or providing more words.");
        }
        const randInt = typeof config.seed !== "undefined" ? (0, random_1.createSeededRandomInt)(config.seed) : random_1.getRandomInt;
        const fromDictRander = (i) => usableDictionaries[i][randInt(0, usableDictionaries[i].length - 1)];
        const dictionariesLength = usableDictionaries.length;
        const separator = config.separator || "";
        // Template-based assembly
        let username;
        let alreadyFormatted = false;
        if (config.template) {
            username = renderTemplate(config.template, usableDictionaries, randInt, separator, config.randomDigits);
        }
        else {
            const selected = [];
            for (let i = 0; i < dictionariesLength; i++) {
                const next = fromDictRander(i);
                selected.push(next);
            }
            const core = formatFromTokens(selected, (_c = config.style) !== null && _c !== void 0 ? _c : "lowerCase", separator);
            username = core + randomNumber(config.randomDigits);
            alreadyFormatted = true;
        }
        if (!alreadyFormatted) {
            username = formatUsername(username, (_d = config.style) !== null && _d !== void 0 ? _d : "lowerCase", separator);
        }
        if (config.length) {
            return username.substring(0, config.length);
        }
        else {
            return username.substring(0, 15);
        }
    }
}
exports.uniqueUsernameGenerator = uniqueUsernameGenerator;
var data_2 = require("./data");
Object.defineProperty(exports, "adjectives", { enumerable: true, get: function () { return data_2.adjectives; } });
Object.defineProperty(exports, "nouns", { enumerable: true, get: function () { return data_2.nouns; } });
var profanity_2 = require("./data/profanity");
Object.defineProperty(exports, "DEFAULT_PROFANITY", { enumerable: true, get: function () { return profanity_2.DEFAULT_PROFANITY; } });
// Helpers
function safeAdjectives() {
    const isBlocked = (0, profanity_1.buildProfanityFilter)(profanity_1.DEFAULT_PROFANITY);
    return data_1.adjectives.filter((w) => !isBlocked(w));
}
function safeNouns() {
    const isBlocked = (0, profanity_1.buildProfanityFilter)(profanity_1.DEFAULT_PROFANITY);
    return data_1.nouns.filter((w) => !isBlocked(w));
}
function titleCaseWord(word) {
    if (!word)
        return word;
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
}
function toWords(input, separator) {
    if (!separator)
        return [input];
    return input.split(separator).filter(Boolean);
}
function formatUsername(base, style, separator) {
    const normalizedSeparator = typeof separator === "string" ? separator : "";
    const parts = toWords(base, normalizedSeparator);
    switch (style) {
        case "upperCase":
            return parts.join(normalizedSeparator).toUpperCase();
        case "capital":
            return parts.map(titleCaseWord).join(normalizedSeparator);
        case "camelCase": {
            const [first, ...rest] = parts.map((p) => p.toLowerCase());
            return [first !== null && first !== void 0 ? first : "", ...rest.map(titleCaseWord)].join("");
        }
        case "pascalCase": {
            return parts.map(titleCaseWord).join("");
        }
        case "kebabCase":
            return parts.map((p) => p.toLowerCase()).join("-");
        case "snakeCase":
            return parts.map((p) => p.toLowerCase()).join("_");
        case "lowerCase":
        default:
            return parts.join(normalizedSeparator).toLowerCase();
    }
}
function formatFromTokens(tokens, style, separator) {
    const normalizedTokens = tokens.map((t) => sanitizeToken(t, separator));
    switch (style) {
        case "upperCase":
            return normalizedTokens.map((t) => t.toUpperCase()).join(separator);
        case "capital":
            {
                const joined = normalizedTokens.join(separator);
                if (!joined)
                    return joined;
                return joined.charAt(0).toUpperCase() + joined.slice(1).toLowerCase();
            }
        case "titleCase":
            return normalizedTokens.map(titleCaseWord).join(separator);
        case "camelCase": {
            const [first, ...rest] = normalizedTokens.map((p) => p.toLowerCase());
            return [first !== null && first !== void 0 ? first : "", ...rest.map(titleCaseWord)].join("");
        }
        case "pascalCase":
            return normalizedTokens.map(titleCaseWord).join("");
        case "kebabCase":
            return normalizedTokens.map((p) => p.toLowerCase()).join("-");
        case "snakeCase":
            return normalizedTokens.map((p) => p.toLowerCase()).join("_");
        case "lowerCase":
        default:
            return normalizedTokens.map((p) => p.toLowerCase()).join(separator);
    }
}
function sanitizeToken(token, separator) {
    if (!token)
        return token;
    if (!separator) {
        // remove non-alphanumeric characters when no explicit separator is requested
        return token.replace(/[^a-zA-Z0-9]/g, "");
    }
    // replace non-alphanumeric with the provided separator and collapse repeats
    const replaced = token.replace(/[^a-zA-Z0-9]+/g, separator);
    const collapsed = replaced.replace(new RegExp(`${escapeRegex(separator)}{2,}`, "g"), separator);
    return trimSeparator(collapsed, separator);
}
function escapeRegex(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function trimSeparator(value, separator) {
    const re = new RegExp(`^${escapeRegex(separator)}|${escapeRegex(separator)}$`, "g");
    return value.replace(re, "");
}
// Template rendering: supports {word} tokens and {digits:n}
function renderTemplate(template, dictionaries, randInt, separator, randomDigits) {
    // Pre-defined tokens: {adjective}, {noun}, positional {0}, {1}, ... and {digits:n}
    const tokenRegex = /\{(adjective|noun|digits(?::\d+)?|\d+)\}/gi;
    const pick = (index) => dictionaries[index][randInt(0, dictionaries[index].length - 1)];
    let adjIndex = -1;
    let nounIndex = -1;
    // Best-effort: try to map first dict to adjective and second to noun
    if (dictionaries.length > 0)
        adjIndex = 0;
    if (dictionaries.length > 1)
        nounIndex = 1;
    return template.replace(tokenRegex, (match) => {
        const inner = match.slice(1, -1);
        if (inner.startsWith("digits")) {
            const parts = inner.split(":");
            const n = parts[1] ? parseInt(parts[1], 10) : (randomDigits !== null && randomDigits !== void 0 ? randomDigits : 0);
            return randomNumber(Number.isFinite(n) ? n : undefined);
        }
        if (inner === "adjective" && adjIndex >= 0)
            return pick(adjIndex);
        if (inner === "noun" && nounIndex >= 0)
            return pick(nounIndex);
        const idx = parseInt(inner, 10);
        if (Number.isFinite(idx) && idx >= 0 && idx < dictionaries.length)
            return pick(idx);
        return match;
    }).replace(/\s+/g, separator || "");
}
