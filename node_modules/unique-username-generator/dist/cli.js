#!/usr/bin/env node
"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("./index");
const fs_1 = require("fs");
function parseArgs(argv) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const args = argv.slice(2);
    const config = {};
    const dictionaries = [];
    for (let i = 0; i < args.length; i++) {
        const a = args[i];
        if (a === "--separator" || a === "-s") {
            config.separator = (_a = args[++i]) !== null && _a !== void 0 ? _a : "";
        }
        else if (a === "--digits" || a === "-d") {
            const n = Number((_b = args[++i]) !== null && _b !== void 0 ? _b : 0);
            if (!Number.isNaN(n))
                config.randomDigits = n;
        }
        else if (a === "--length" || a === "-l") {
            const n = Number((_c = args[++i]) !== null && _c !== void 0 ? _c : 0);
            if (!Number.isNaN(n) && n > 0)
                config.length = n;
        }
        else if (a === "--style") {
            config.style = args[++i];
        }
        else if (a === "--upper" || a === "-U") {
            config.style = "upperCase";
        }
        else if (a === "--dict" || a === "-D") {
            // comma-separated list
            const list = ((_d = args[++i]) !== null && _d !== void 0 ? _d : "").split(",").map((x) => x.trim()).filter(Boolean);
            if (list.length > 0)
                dictionaries.push(list);
        }
        else if (a === "--exclude" || a === "-x") {
            const list = ((_e = args[++i]) !== null && _e !== void 0 ? _e : "").split(",").map((x) => x.trim()).filter(Boolean);
            config.exclude = list;
        }
        else if (a === "--seed") {
            config.seed = args[++i];
        }
        else if (a === "--template" || a === "-t") {
            config.template = (_f = args[++i]) !== null && _f !== void 0 ? _f : "";
        }
        else if (a === "--count" || a === "-c") {
            const n = Number((_g = args[++i]) !== null && _g !== void 0 ? _g : 1);
            if (!Number.isNaN(n) && n > 0)
                config.count = n;
        }
        else if (a === "--unique" || a === "-u") {
            config.unique = true;
        }
        else if (a === "--out" || a === "-o") {
            config.out = (_h = args[++i]) !== null && _h !== void 0 ? _h : "";
        }
        else if (a === "--unsafe") {
            config.unsafe = true;
        }
        else if (a === "--help" || a === "-h") {
            printHelp();
            process.exit(0);
        }
    }
    config.dictionaries = dictionaries.length > 0 ? dictionaries : [index_1.adjectives, index_1.nouns];
    return config;
}
function printHelp() {
    const text = `unique-username-generator

Usage: usergen [options]

Options:
  -s, --separator <sep>     Separator between words (default: empty)
  -d, --digits <n>          Number of random digits to append (0-6)
  -l, --length <n>          Maximum username length (default: 15)
      --style <style>       Style: lowerCase | upperCase | capital | camelCase | pascalCase | kebabCase | snakeCase
  -U, --upper               Shortcut for --style upperCase
  -D, --dict <a,b,c>        Provide a custom dictionary (can be used multiple times)
  -x, --exclude <a,b,c>     Extra words to exclude
      --seed <seed>         Deterministic seed for reproducible output
  -t, --template <tpl>      Template, e.g. "{adjective}-{noun}-{digits:2}"
  -c, --count <n>           Generate many
  -u, --unique              Ensure unique usernames within this run
  -o, --out <file>          Write results to a file (UTF-8)
      --unsafe              Disable profanity filtering
  -h, --help                Show help
`;
    // eslint-disable-next-line no-console
    console.log(text);
}
function main() {
    const parsed = parseArgs(process.argv);
    const { count, unique, out, unsafe } = parsed, cfg = __rest(parsed, ["count", "unique", "out", "unsafe"]);
    if (unsafe) {
        cfg.profanityList = [];
        cfg.exclude = [];
    }
    const list = count && count > 1
        ? (0, index_1.generateMany)(Object.assign(Object.assign({}, cfg), { count, unique: !!unique }))
        : [(0, index_1.uniqueUsernameGenerator)(cfg)];
    if (out) {
        (0, fs_1.writeFileSync)(out, list.join("\n"), "utf8");
    }
    else {
        // eslint-disable-next-line no-console
        list.forEach((u) => console.log(u));
    }
}
main();
